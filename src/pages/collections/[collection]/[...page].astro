---
import type { GetStaticPaths, Page } from "astro";
import PageLayout from "@/layouts/Base.astro";
import PostPreview from "@/components/listing-layout/PostPreview.astro";
import PostPreviewFull from "@/components/listing-layout/PostPreviewFull.astro";
import PostCardGallery from "@/components/listing-layout/PostCardGallery.astro";
import Pagination from "@/components/listing-layout/Paginator.astro";
import { getAllPosts, getUniqueTags, getAllTagsWithCounts } from "@/lib/notion/client";
import type { Post, SelectProperty } from "@/lib/interfaces";
import { getCollectionsWDesc, slugify } from "@/utils";
import { getNotionColorToTailwindColor } from "@/utils/style-helpers";
import {
	FULL_PREVIEW_COLLECTIONS,
	HIDE_UNDERSCORE_SLUGS_IN_LISTS,
	NUMBER_OF_POSTS_PER_PAGE,
	LAST_BUILD_TIME,
	LISTING_VIEW,
} from "@/constants";
import {
	getNavLink,
	resetCurrentHeadings,
	resetFirstImage,
	getInterlinkedContentInPage,
} from "@/lib/blog-helpers";
import Icon from "@/components/ui/Icon.astro";

export const getStaticPaths = (async ({ paginate }) => {
	let posts = await getAllPosts();
	if (HIDE_UNDERSCORE_SLUGS_IN_LISTS) {
		posts = posts.filter((post) => !post.Slug.startsWith("_"));
	}

	const collections = await getCollectionsWDesc();

	const allTagsWithCounts = await getAllTagsWithCounts();

	return collections.flatMap((collection) => {
		let collectionPosts = posts.filter((post) => post.Collection === collection.name);
		collectionPosts.sort((a, b) => (a.Pinned === b.Pinned ? 0 : a.Pinned ? -1 : 1));
		const uniqueTags = getUniqueTags(collectionPosts);

		const uniqueTagsWithCounts = uniqueTags.map((tag) => {
			const tagWithCount = allTagsWithCounts.find((t) => t.name === tag.name);
			return {
				...tag,
				count: tagWithCount ? tagWithCount.count : 0,
			};
		});

		return paginate(collectionPosts, {
			params: { collection: slugify(collection.name) },
			props: {
				collection: collection.name,
				description: collection.description,
				uniqueTags: uniqueTagsWithCounts,
			},
			pageSize: NUMBER_OF_POSTS_PER_PAGE,
		});
	});
}) satisfies GetStaticPaths;

interface Props {
	page: Page<Post>;
	collection: string;
	description: string;
	uniqueTags: (SelectProperty & { count: number })[];
}

const { page, collection, description, uniqueTags } = Astro.props as Props;

// Compute caching info for each post in page.data
const allPosts = await getAllPosts();
const allPostsMap: Record<string, Post> = Object.fromEntries(allPosts.map((p) => [p.PageId, p]));

const postsWithCacheInfo = page.data.map((post) => {
	const interlinkedContentInPage = getInterlinkedContentInPage(post.PageId);
	const linkedPageIdsSet = new Set<string>();

	if (interlinkedContentInPage) {
		interlinkedContentInPage.forEach((ref) => {
			if (ref.link_to_pageid) {
				linkedPageIdsSet.add(ref.link_to_pageid);
			}
			if (ref.other_pages) {
				ref.other_pages.forEach((richText) => {
					if (richText.InternalHref?.PageId) {
						linkedPageIdsSet.add(richText.InternalHref.PageId);
					} else if (richText.Mention?.Page?.PageId) {
						linkedPageIdsSet.add(richText.Mention.Page.PageId);
					}
				});
			}
		});
	}

	const linkedPageIds = Array.from(linkedPageIdsSet);

	const postLastUpdatedBeforeLastBuild =
		LAST_BUILD_TIME && post?.LastUpdatedTimeStamp && post.LastUpdatedTimeStamp < LAST_BUILD_TIME;

	const linkedPostsUpdated =
		!LAST_BUILD_TIME ||
		(linkedPageIds.length > 0 &&
			linkedPageIds.some((pageId) => {
				const linkedPost = allPostsMap[pageId];
				return linkedPost && linkedPost.LastUpdatedTimeStamp > LAST_BUILD_TIME;
			}));

	const shouldUseCache = postLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

	return { post, shouldUseCache, postLastUpdatedBeforeLastBuild };
});

const meta = {
	title: `${collection}`,
	description: description || "Read my collection of posts.",
	ogImage: "/og-image/collectionpage---" + collection + ".png",
};

const paginationProps = {
	...(page.url.prev && {
		prevUrl: { url: getNavLink(page.url.prev), text: "Previous Posts" },
	}),
	...(page.url.next && {
		nextUrl: { url: getNavLink(page.url.next), text: "Next Posts" },
	}),
};
---

<>
	<PageLayout meta={meta}>
		<h1 class="title mb-6">{collection}</h1>
		{description && <q class="-mt-3 mb-6 block italic">{description}</q>}
		<div class="grid grid-cols-3 gap-y-16 sm:grid-cols-4 sm:items-start sm:gap-x-8">
			<section aria-label="Blog post list" class="col-span-3 print:col-span-full">
				{
					FULL_PREVIEW_COLLECTIONS.includes(collection) ? (
						/* Full preview (stream) mode for full-preview collections */
						<ul class="space-y-4 text-start">
							{resetFirstImage() &&
								postsWithCacheInfo.map(
									({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => (
										<>
											{resetCurrentHeadings() && (
												<li>
													<PostPreviewFull
														post_full_preview={post}
														shouldUseCache={shouldUseCache}
														postLastUpdatedBeforeLastBuild={postLastUpdatedBeforeLastBuild}
														as="h2"
														withDesc
													/>
												</li>
											)}
											<hr class="divider bg-accent/20 mx-auto my-4 h-0.5 w-full rounded-sm border-none" />
										</>
									),
								)}
						</ul>
					) : LISTING_VIEW === "gallery" ? (
						/* Gallery mode for non-full-preview collections */
						<div class="gallery-grid">
							{postsWithCacheInfo.map(({ post }) => (
								<PostCardGallery post={post} as="h2" />
							))}
						</div>
					) : (
						/* List mode for non-full-preview collections */
						<ul class="space-y-4 text-start">
							{postsWithCacheInfo.map(({ post }) => (
								<li class="flex max-w-full flex-col flex-wrap gap-1.5 [&_q]:basis-full">
									<PostPreview post={post} as="h2" withDesc />
								</li>
							))}
						</ul>
					)
				}
				<Pagination {...paginationProps} />
			</section>
			{
				!!uniqueTags.length && (
					<aside class="col-span-3 sm:col-span-1 print:hidden">
						<h2 class="text-accent-2 mb-4 flex items-center text-lg font-semibold">
							<Icon class="h-6 w-6" name={"tag-multiple"} aria-hidden="true" focusable="false" />
							Tags
						</h2>
						<ul class="flex flex-wrap gap-2">
							{uniqueTags.map((tag) => (
								<li>
									<a
										class={`flex items-center justify-center rounded-lg px-2 ${getNotionColorToTailwindColor(
											tag.color + "-background",
											true,
										)}`}
										href={getNavLink("/tags/" + slugify(tag.name) + "/")}
										aria-label={`View all posts with the tag: ${tag.name}`}
									>
										{tag.name}
										<span class="ml-2 rounded-sm bg-gray-100 px-1 text-xs text-rose-800 dark:bg-gray-800 dark:text-rose-300">
											{tag.count}
										</span>
									</a>
								</li>
							))}
						</ul>
						<span class="mt-4 block sm:text-end">
							<a
								class="sm:hover:text-accent inline-flex items-center gap-1"
								href={getNavLink("/tags/")}
								aria-label="View all tags"
							>
								View all
								<Icon class="h-4 w-4" name={"next"} aria-hidden="true" focusable="false" />
							</a>
						</span>
					</aside>
				)
			}
		</div>
	</PageLayout>
	{
		FULL_PREVIEW_COLLECTIONS.includes(collection) && (
			<>
				<button
					id="to-top-btn"
					class="fixed end-4 bottom-8 z-30 flex h-10 w-10 translate-y-28 cursor-pointer items-center justify-center rounded-full border-2 border-transparent bg-zinc-200 text-3xl opacity-0 transition-all duration-300 hover:border-zinc-400 data-[show=true]:translate-y-0 data-[show=true]:opacity-100 sm:end-8 sm:h-12 sm:w-12 dark:bg-zinc-700 print:hidden"
					aria-label="Back to Top"
					data-show="false"
				>
					<Icon
						name={"to-top"}
						class="h-6 w-6"
						aria-label="Go Back to Top"
						stroke-linecap="round"
					/>
				</button>
				<script src="../../../scripts/to-top-btn.ts" />
			</>
		)
	}
</>
