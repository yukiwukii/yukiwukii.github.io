---
import NotionBlocks from "@/components/NotionBlocks.astro";
import PostLayout from "@/layouts/BlogPost.astro";
import {
	resetCurrentHeadings,
	resetFirstImage,
	setCurrentHeadings,
	setTrackCurrentPageId,
	getInterlinkedContentInPage,
	loadCachedHtml,
	loadCachedHeadings,
	saveCachedHeadings,
} from "@/lib/blog-helpers";
import { getAllPosts, getPostContentByPostId } from "@/lib/notion/client";
import type { Post } from "@/lib/interfaces";
import { buildHeadings } from "@/utils";
import {
	LAST_BUILD_TIME,
	CITATIONS,
	BIBTEX_CITATIONS_ENABLED,
	MARKDOWN_EXPORT_ENABLED,
} from "@/constants";
import { adjustedFootnotesConfig } from "@/lib/notion/client";
import FootnotesSection from "@/components/auto-added-sections/FootnotesSection.astro";
import BibliographySection from "@/components/auto-added-sections/BibliographySection.astro";
import CiteThisPage from "@/components/auto-added-sections/CiteThisPage.astro";
import { renderExternalHtml } from "@/lib/external-content/external-html-content";
import { renderExternalMarkdown } from "@/lib/external-content/external-markdown-content";
import { renderExternalMdx } from "@/lib/external-content/external-mdx-content";
export async function getStaticPaths() {
	const posts = (await getAllPosts()).filter((post) => !post.IsExternal || !!post.ExternalContent);
	const allPostsMap: Record<string, Post> = Object.fromEntries(posts.map((p) => [p.PageId, p])); // Map of PageId to Post

	return posts.map((post) => {
		const interlinkedContentInPage = getInterlinkedContentInPage(post.PageId);
		const linkedPageIdsSet = new Set<string>(); // Use a Set to collect unique PageIds

		// Collect linked PageIds, automatically deduplicating
		if (interlinkedContentInPage) {
			interlinkedContentInPage.forEach((ref) => {
				if (ref.link_to_pageid) {
					linkedPageIdsSet.add(ref.link_to_pageid);
				}
				if (ref.other_pages) {
					ref.other_pages.forEach((richText) => {
						if (richText.InternalHref?.PageId) {
							linkedPageIdsSet.add(richText.InternalHref.PageId);
						} else if (richText.Mention?.Page?.PageId) {
							linkedPageIdsSet.add(richText.Mention.Page.PageId);
						}
					});
				}
			});
		}

		const linkedPageIds = Array.from(linkedPageIdsSet); // Convert Set back to an array

		// Check if the post was updated before LAST_BUILD_TIME
		const isExternal = !!post.ExternalContent;
		const postLastUpdatedBeforeLastBuild =
			!isExternal && LAST_BUILD_TIME && post?.LastUpdatedTimeStamp
				? post.LastUpdatedTimeStamp < LAST_BUILD_TIME
				: false;

		// Check if any linked post was updated after LAST_BUILD_TIME
		const linkedPostsUpdated =
			!LAST_BUILD_TIME ||
			(linkedPageIds.length > 0 &&
				linkedPageIds.some((pageId) => {
					const linkedPost = allPostsMap[pageId];
					return linkedPost && linkedPost.LastUpdatedTimeStamp > LAST_BUILD_TIME;
				}));

		const shouldUseCache = !isExternal && postLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

		return {
			params: { slug: post.Slug },
			props: { post, shouldUseCache, postLastUpdatedBeforeLastBuild },
		};
	});
}

interface Props {
	post: Post;
	shouldUseCache: boolean;
	postLastUpdatedBeforeLastBuild: boolean;
}

const { post, shouldUseCache, postLastUpdatedBeforeLastBuild } = Astro.props;
const hasExternalDescriptor = !!post?.ExternalContent;
const externalType = post?.ExternalContent?.type ?? null;
const isExternalHtml = externalType === "html";
const isExternalMarkdown = externalType === "markdown";
const isExternalMdx = externalType === "mdx";

resetCurrentHeadings();
let postFound = true;
let headings = null;
let blocks = null;
let interlinkedContentInPage = null;
let externalHtml = "";
let MdxComponent = null;
let mdxComponents = {};

if (!post) {
	console.log("Post not found. slug: ${slug}");
	postFound = false;
}

// Load cached HTML only if shouldUseCache is true
let cachedHtml = "";
if (postFound && !hasExternalDescriptor) {
	cachedHtml = await loadCachedHtml(post.Slug, shouldUseCache);
}

// Load cached headings if available
let cachedHeadings = null;
if (postFound && !hasExternalDescriptor) {
	cachedHeadings = await loadCachedHeadings(post.Slug, postLastUpdatedBeforeLastBuild);
}

let footnotesInPage = null;
let citationsInPage = null;

if (postFound && isExternalHtml) {
	const { html, headings: externalHeadings } = renderExternalHtml(post);
	externalHtml = html;
	headings = externalHeadings;
	setCurrentHeadings(headings || []);
} else if (postFound && isExternalMarkdown) {
	const markdownResult = await renderExternalMarkdown(post);
	if (markdownResult.cachedHtml) {
		externalHtml = markdownResult.cachedHtml;
		headings = markdownResult.headings;
		footnotesInPage = null;
		citationsInPage = null;
		interlinkedContentInPage = null;
	} else {
		blocks = markdownResult.blocks;
		headings = markdownResult.headings;
		interlinkedContentInPage = markdownResult.interlinkedContent;
		footnotesInPage = markdownResult.footnotes;
		citationsInPage = markdownResult.citations;
	}
	setCurrentHeadings(headings || []);
} else if (postFound && isExternalMdx) {
	const mdxResult = await renderExternalMdx(post);
	blocks = mdxResult.blocks;
	headings = mdxResult.headings;
	interlinkedContentInPage = mdxResult.interlinkedContent;
	footnotesInPage = mdxResult.footnotes;
	citationsInPage = mdxResult.citations;
	MdxComponent = mdxResult.Component;
	mdxComponents = mdxResult.mdxComponents;
	setCurrentHeadings(headings || []);
} else if (postFound) {
	const result = await getPostContentByPostId(post);
	blocks = result.blocks;
	interlinkedContentInPage = result.interlinkedContentInPage;
	footnotesInPage = result.footnotesInPage;
	citationsInPage = result.citationsInPage;
	// Use cached headings if available, otherwise build and save them
	if (cachedHeadings) {
		headings = cachedHeadings;
	} else {
		headings = buildHeadings(blocks);
		await saveCachedHeadings(post.Slug, headings);
	}

	setCurrentHeadings(headings);
}
---

{
	postFound && resetFirstImage() && setTrackCurrentPageId(post.PageId) && (
		<PostLayout
			post={post}
			headings={headings}
			shouldUseCache={shouldUseCache}
			footnotesInPage={footnotesInPage}
			showCopyMarkdownButton={MARKDOWN_EXPORT_ENABLED && !hasExternalDescriptor}
		>
			<div
				class="post-body max-w-[708px] print:max-w-full"
				data-html-type={shouldUseCache && cachedHtml ? "cached" : "new"}
			>
				{isExternalHtml ? (
					<>
						{externalHtml ? (
							<div class="external-html" set:html={externalHtml} />
						) : (
							<p class="text-sm text-red-500">
								External HTML content is missing for this post. Check the configured repository.
							</p>
						)}
						{CITATIONS?.["add-cite-this-post-section"] && <CiteThisPage post={post} />}
						{adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.enabled &&
							adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.[
								"generate-footnotes-section"
							] &&
							footnotesInPage && <FootnotesSection footnotes={footnotesInPage} />}
						{BIBTEX_CITATIONS_ENABLED &&
							CITATIONS?.["extract-and-process-bibtex-citations"]?.[
								"generate-bibliography-section"
							] &&
							citationsInPage &&
							citationsInPage.length > 0 && <BibliographySection citations={citationsInPage} />}
					</>
				) : isExternalMarkdown ? (
					<>
						{externalHtml ? (
							<div class="external-html" set:html={externalHtml} />
						) : blocks ? (
							<NotionBlocks blocks={blocks} />
						) : (
							<p class="text-sm text-red-500">
								Markdown content is missing for this post. Check the configured repository.
							</p>
						)}
						{!externalHtml && CITATIONS?.["add-cite-this-post-section"] && (
							<CiteThisPage post={post} />
						)}
						{!externalHtml &&
							adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.enabled &&
							adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.[
								"generate-footnotes-section"
							] &&
							footnotesInPage && <FootnotesSection footnotes={footnotesInPage} />}
						{!externalHtml &&
							BIBTEX_CITATIONS_ENABLED &&
							CITATIONS?.["extract-and-process-bibtex-citations"]?.[
								"generate-bibliography-section"
							] &&
							citationsInPage &&
							citationsInPage.length > 0 && <BibliographySection citations={citationsInPage} />}
					</>
				) : isExternalMdx ? (
					<>
						{MdxComponent ? (
							<div class="mdx-notion">
								<MdxComponent components={mdxComponents} />
							</div>
						) : (
							<p class="text-sm text-red-500">
								MDX content is missing for this post. Check the configured repository.
							</p>
						)}
						{CITATIONS?.["add-cite-this-post-section"] && <CiteThisPage post={post} />}
						{adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.enabled &&
							adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.[
								"generate-footnotes-section"
							] &&
							footnotesInPage && <FootnotesSection footnotes={footnotesInPage} />}
						{BIBTEX_CITATIONS_ENABLED &&
							CITATIONS?.["extract-and-process-bibtex-citations"]?.[
								"generate-bibliography-section"
							] &&
							citationsInPage &&
							citationsInPage.length > 0 && <BibliographySection citations={citationsInPage} />}
					</>
				) : shouldUseCache && cachedHtml ? (
					<div set:html={cachedHtml} />
				) : (
					<>
						<NotionBlocks blocks={blocks} />
						{CITATIONS?.["add-cite-this-post-section"] && <CiteThisPage post={post} />}
						{adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.enabled &&
							adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.[
								"generate-footnotes-section"
							] &&
							footnotesInPage && <FootnotesSection footnotes={footnotesInPage} />}
						{BIBTEX_CITATIONS_ENABLED &&
							CITATIONS?.["extract-and-process-bibtex-citations"]?.[
								"generate-bibliography-section"
							] &&
							citationsInPage &&
							citationsInPage.length > 0 && <BibliographySection citations={citationsInPage} />}
					</>
				)}
			</div>
		</PostLayout>
	)
}
