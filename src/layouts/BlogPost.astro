---
import BaseLayout from "./Base.astro";
import BlogHero from "@/components/layout/Hero.astro";
import TOC from "@/components/auto-added-sections/TOC.astro";
import WebMentions from "@/components/auto-added-sections/webmentions/index.astro";
import type { Post } from "@/lib/interfaces";
import type { Heading } from "@/types";
import PostComments from "@/components/auto-added-sections/PostComments.astro";
import { INTERLINKED_CONTENT } from "@/constants";
import { adjustedFootnotesConfig } from "@/lib/notion/client";
import InterlinkedContentSection from "@/components/auto-added-sections/interlinked-content/InterlinkedContentSection.astro";
import Icon from "@/components/ui/Icon.astro";
import CopyMarkdownButton from "@/components/auto-added-sections/CopyMarkdownButton.astro";

interface Props {
	post: Post;
	ogImage?: string;
	headings: Heading[];
	shouldUseCache: boolean;
	footnotesInPage?: any[] | null;
	showCopyMarkdownButton?: boolean;
}

const {
	post,
	ogImage,
	headings,
	shouldUseCache,
	footnotesInPage,
	showCopyMarkdownButton = false,
} = Astro.props;

// Add Interlinked Content heading to TOC if interlinked content exist
INTERLINKED_CONTENT
	? headings.push({
			text: "Interlinked Content",
			slug: "autogenerated-interlinked-content",
			depth: 1,
		})
	: headings;

// Add Footnotes heading to TOC if footnotes exist and generate-footnotes-section is true
if (
	adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.enabled &&
	adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.["generate-footnotes-section"] &&
	footnotesInPage &&
	footnotesInPage.length > 0
) {
	headings.push({
		text: "Footnotes",
		slug: "autogenerated-footnotes",
		depth: 1,
	});
}

const socialImage = ogImage ? ogImage : `/og-image/${post.Slug}.png`;
const articleDate = new Date(post.Date).toISOString();

// Get author string for meta tag (falls back to siteInfo.author in BaseHead if undefined)
const getMetaAuthor = (): string | undefined => {
	if (post.Authors && post.Authors.length > 0) {
		return post.Authors.map((a) => a.name).join(", ");
	}
	return undefined;
};
const metaAuthor = getMetaAuthor();
---

<BaseLayout
	meta={{
		title: post.Title,
		description: post.Excerpt,
		articleDate,
		ogImage: socialImage,
		author: metaAuthor,
	}}
>
	<div class="max-w-[708px] sm:mr-20 print:mr-auto print:max-w-full">
		<article class="break-words" data-pagefind-body>
			<div id="blog-hero">
				<BlogHero post={post} />
			</div>
			<div class="mt-8">
				<slot />
				{/* Post body content */}
				<hr class="divider" />
				{
					INTERLINKED_CONTENT && (
						<InterlinkedContentSection post={post} shouldUseCache={shouldUseCache} />
					)
				}
			</div>
		</article>
		{!!headings.length && <TOC headings={headings} />}
	</div>
	<div class="max-w-[708px] sm:mr-20 print:hidden">
		<aside class="" data-pagefind-ignore="all">
			<WebMentions />
			<PostComments post={post} />
		</aside>
	</div>
	<button id="to-top-btn" class="to-top-btn" aria-label="Back to Top" data-show="false">
		<Icon name={"to-top"} class="h-6 w-6" aria-label="Go Back to Top" stroke-linecap="round" />
	</button>
	{
		showCopyMarkdownButton && (
			<CopyMarkdownButton class="copy-floating-btn" buttonClass="justify-center" />
		)
	}
</BaseLayout>

<script>
	document.addEventListener("DOMContentLoaded", function () {
		const scrollBtn = document.getElementById("to-top-btn");
		const targetHeader = document.getElementById("blog-hero");

		function callback(entries) {
			entries.forEach((entry) => {
				if (entry.target === targetHeader) {
					scrollBtn.dataset.show = (!entry.isIntersecting).toString();
				}
			});
		}

		scrollBtn.addEventListener("click", () => {
			document.documentElement.scrollTo({ top: 0, behavior: "smooth" });
		});
		const observer = new IntersectionObserver(callback);
		observer.observe(targetHeader);
	});
</script>
