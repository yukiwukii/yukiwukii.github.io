---
import type { Block, Post, InterlinkedContentInPage } from "@/lib/interfaces";
import createMetascraper from "metascraper";
import metascraperDescription from "metascraper-description";
import metascraperImage from "metascraper-image";
import metascraperTitle from "metascraper-title";
import NBlocksPopover from "@/components/popover/NBlocksPopover.astro";
import { buildURLToHTMLMap, getInterlinkedContentLink } from "@/lib/blog-helpers";
import Icon from "@/components/ui/Icon.astro";
import { getSymbolForLinkedContent } from "@/utils";

interface Props {
	post: Post;
	filteredInterlinkedContentInPage: InterlinkedContentInPage[];
}
const { post, filteredInterlinkedContentInPage } = Astro.props;
const groupedInterlinkedContent: { [key: string]: Block[] } =
	filteredInterlinkedContentInPage.reduce((acc, ref) => {
		// Group by direct_nonmedia_link and collect Block objects
		if (ref.direct_nonmedia_link && !ref.direct_nonmedia_link.includes("tiktok.com")) {
			const key = ref.direct_nonmedia_link;
			acc[key] = acc[key] || [];
			acc[key].push(ref.block);
		}

		// Group by each Href in external_hrefs and collect Block objects
		ref.external_hrefs.forEach((richText) => {
			if (richText.Href && !richText.Href.includes("tiktok.com")) {
				const key = richText.Href;
				acc[key] = acc[key] || [];
				acc[key].push(ref.block);
			}
		});

		return acc;
	}, {});

const blockIdLinks = {};
const urlList: URL[] = [];
const hrefMetaData = {};

if (groupedInterlinkedContent) {
	for (const hrefLink of Object.keys(groupedInterlinkedContent)) {
		let url: URL;
		try {
			let urlToUse = hrefLink;
			if (!urlToUse.startsWith("http://") && !urlToUse.startsWith("https://")) {
				urlToUse = "https://" + urlToUse;
			}
			url = new URL(urlToUse);
			urlList.push(url);
			for (const block of groupedInterlinkedContent[hrefLink]) {
				const result = await getInterlinkedContentLink(post.PageId, undefined, block, true);
				blockIdLinks[block.Id] = result[0];
			}
		} catch (err) {
			console.log(`Error processing link ${hrefLink}:`, err);
			delete groupedInterlinkedContent[hrefLink];
			continue;
		}
	}
}

const urlMap = await buildURLToHTMLMap(urlList);

const metascraper = createMetascraper([
	metascraperTitle(),
	metascraperImage(),
	metascraperDescription(),
]);

if (groupedInterlinkedContent && Object.keys(groupedInterlinkedContent).length > 0 && urlMap) {
	for (const hrefLink of Object.keys(groupedInterlinkedContent)) {
		let url: URL;
		let metadata: Record<string, string>;
		try {
			let urlToUse = hrefLink;
			if (!urlToUse.startsWith("http://") && !urlToUse.startsWith("https://")) {
				urlToUse = "https://" + urlToUse;
			}
			url = new URL(urlToUse);
			// Remove ONLY text fragments for metascraper
			const urlForMetascraper = url.toString().replace(/#:~:text=.*$/, "");

			const html = urlMap[hrefLink];
			if (html) {
				metadata = await metascraper({ html, url: urlForMetascraper });
				if (!metadata || (metadata && !metadata.title)) {
					delete groupedInterlinkedContent[hrefLink];
					continue;
				} else {
					hrefMetaData[hrefLink] = metadata;
				}
			} else {
				delete groupedInterlinkedContent[hrefLink];
			}
		} catch (err) {
			console.log(`Error processing metadata for ${hrefLink}:`, err);
			delete groupedInterlinkedContent[hrefLink];
			continue;
		}
	}
}
---

{
	groupedInterlinkedContent && Object.keys(groupedInterlinkedContent).length > 0 && urlMap && (
		<>
			<details class="toggle no-rss" id="autogenerated-external-links">
				<summary class="flex max-w-full cursor-pointer list-outside list-none gap-2">
					<div class="-ml-7">
						<Icon
							name={"toggle-triangle"}
							class="rotate-svg h-6 w-6 shrink-0 transition-all duration-300"
							aria-label="Toggle open/close"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="2"
						/>
					</div>
					<div>
						<span class="font-semibold">External Links On This Page</span>
					</div>
				</summary>
				<div class="pl-2">
					{Object.entries(groupedInterlinkedContent).map(([hrefLink, blocks]) => (
						<div>
							<div class="inline-block">
								<a
									href={hrefLink}
									class="text-link hover:decoration-accent-2 no-underline hover:underline hover:underline-offset-4"
								>
									{hrefMetaData[hrefLink].title.length > 35
										? `${hrefMetaData[hrefLink].title.slice(0, 35)}â€¦`
										: hrefMetaData[hrefLink].title}
								</a>
								{" at "}

								{blocks.map((block, index) => (
									<NBlocksPopover
										block={block}
										linkedTo={blockIdLinks[block.Id]}
										popoverSpanText={`[${getSymbolForLinkedContent(index)}]`}
										isInterlinkedBack={true}
										linkText="Jump to"
									/>
								))}
							</div>
						</div>
					))}
				</div>
			</details>
			<br />
		</>
	)
}

<style>
	.toggle > summary > a {
		display: inline;
	}
	details[open] > summary > div > .shrink-0.rotate-svg {
		transform: rotate(90deg);
	}
	summary::-webkit-details-marker {
		display: none;
	}
</style>
