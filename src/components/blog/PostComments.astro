---
import { GISCUS, BLUESKY_COMM } from "@/constants";
import Icon from "@/components/Icon";
import type { Post } from "src/lib/interfaces";
import { getPostLink } from "@/lib/blog-helpers";

interface Props {
	post: Post;
}

const { post } = Astro.props;

const post_slug =new URL(getPostLink(post.Slug), import.meta.env.SITE).toString();
const bluesky_url = post.BlueSkyPostLink || "";

const filled_in_giscus =
	GISCUS &&
	GISCUS["data-repo"] &&
	GISCUS["data-repo-id"] &&
	GISCUS["data-category"] &&
	GISCUS["data-category-id"];
---

{(filled_in_giscus ||
  (BLUESKY_COMM &&
   BLUESKY_COMM["show-comments-from-bluesky"] &&
   (bluesky_url ||
    (BLUESKY_COMM["auto-search-for-match"] &&
     BLUESKY_COMM["auto-search-for-match"]["turn-on-auto-search"] &&
     BLUESKY_COMM["auto-search-for-match"]["author"])))
) && (
  <div id="webtrotion-post-comments">
    <h2
            class="non-toggle-h2 mb-4 mt-8 cursor-pointer text-2xl font-normal"
            id="webtrotion-post-comments-header"
            onclick="
            var fullUrl = `${window.location.origin}${window.location.pathname}#${id}`;
            navigator.clipboard.writeText(fullUrl);
            window.history.pushState(null, '', fullUrl);
            document.getElementById(`${id}`).scrollIntoView({ behavior: 'smooth' });
          "
          >
            Comments
    </h2>
    <div class="tabs-container flex flex-col items-left w-full my-8 mx-auto">
      <div class="tabs flex gap-4 mb-4">
        {(BLUESKY_COMM &&
          BLUESKY_COMM["show-comments-from-bluesky"] &&
          (bluesky_url ||
            (BLUESKY_COMM["auto-search-for-match"] &&
            BLUESKY_COMM["auto-search-for-match"]["turn-on-auto-search"] &&
            BLUESKY_COMM["auto-search-for-match"]["author"]))) && (
          <button class="tab px-4 py-2 cursor-pointer flex items-center gap-2 border-b-2 border-transparent" data-tab="bluesky"><Icon class="h-6 w-6" name={"bluesky"} aria-label={"Bluesky Comments"} focusable="false" />Bluesky</button>
        )}
        {filled_in_giscus && <button class="tab px-4 py-2 cursor-pointer flex items-center gap-2 border-b-2 border-transparent" data-tab="giscus"><Icon class="h-6 w-6" name={"github"} aria-label={"Github Hosted Comments"} focusable="false" />Giscus</button>}
      </div>
      <div class="tab-content w-full">
        {(BLUESKY_COMM &&
          BLUESKY_COMM["show-comments-from-bluesky"] &&
          (bluesky_url ||
            (BLUESKY_COMM["auto-search-for-match"] &&
            BLUESKY_COMM["auto-search-for-match"]["turn-on-auto-search"] &&
            BLUESKY_COMM["auto-search-for-match"]["author"]))) && (
          <div class="tab-pane w-full" id="bluesky-tab" hidden>
            <bluesky-comments
              url={
                bluesky_url
                  ? bluesky_url
                  : (BLUESKY_COMM &&
                    BLUESKY_COMM["auto-search-for-match"] &&
                    BLUESKY_COMM["auto-search-for-match"]["turn-on-auto-search"] &&
                    BLUESKY_COMM["auto-search-for-match"]["author"])
                    ? post_slug
                    : ""
              }>
            </bluesky-comments>
            <script type="module" define:vars={{ BLUESKY_COMM }}>
              class BlueskyComments extends HTMLElement {
                static properties = {
                  /** The URL of the Bluesky post to use as the parent */
                  url: { type: String },
                };

                #observer;
                #loaded = false;
                constructor() {
                  super();
                  this.attachShadow({ mode: "open" });
                  this.shadowRoot.innerHTML = /*html*/ `
                  <style>
                  :host {
                    --bluesky-font-size: 0.875rem;
                    --bluesky-text-color: rgb(var(--theme-text)/1);
                    --bluesky-handle-color: rgb(var(--theme-text)/0.5);
                    --bluesky-footer-text-color: rgb(111, 134, 159);
                    --bluesky-bg-color: rgb(var(--theme-bg)/1);
                    --bluesky-spacing-xs: 0.3125rem;
                    --bluesky-spacing-sm: 0.5rem;
                    --bluesky-spacing-md: 0.625rem;
                    --bluesky-avatar-size: 14px;
                    --bluesky-avatar-bg: rgb(var(--theme-text)/0.1);

                    /* Comments Structure */
                    --bluesky-reply-border-width: 0.125rem;

                    /* Footer */
                    --bluesky-footer-font-size: 0.75rem;
                    --bluesky-icon-size: 1rem;
                    --bluesky-border-color: rgb(var(--theme-quote)/0.2);

                  }

                  /* Container Styles */
                  .comments {
                    font-size: var(--bluesky-font-size);
                    background-color: var(--bluesky-bg-color);
                    padding: var(--bluesky-spacing-md) 0;
                    color: var(--bluesky-text-color);
                  }

                  /* Comment Structure */
                  .comment:not(.reply) {
                    padding-top: var(--bluesky-spacing-md);
                    padding-bottom: var(--bluesky-spacing-md);
                  }

                  .comment.reply {
                    padding-top: var(--bluesky-spacing-xs);
                    border-left: var(--bluesky-reply-border-width) solid var(--bluesky-border-color);
                    margin-left: var(--bluesky-spacing-md);
                  }

                  .avatar {
                    width: var(--bluesky-avatar-size);
                    height: var(--bluesky-avatar-size);
                    border-radius: 50%;
                    object-fit: cover;
                  }

                  .default-avatar {
                    width: var(--bluesky-avatar-size);
                    height: var(--bluesky-avatar-size);
                    border-radius: 50%;
                    background-color: var(--bluesky-avatar-bg);
                  }

                  .comment-header {
                    display: flex;
                    align-items: center;
                    gap: var(--bluesky-spacing-md);
                    padding-left: var(--bluesky-spacing-sm);
                  }

                  .comment-header > div:not(:first-child) {
                    display: flex;
                    align-items: center;
                    gap: 4px;  /* space between elements */
                    flex: 1;   /* take up remaining space */
                    min-width: 0; /* allows text truncation to work */
                  }

                  .comment-footer {
                    display: flex;
                    gap: var(--bluesky-spacing-md);
                    align-items: center;
                    margin-bottom: var(--bluesky-spacing-xs);
                    font-size: var(--bluesky-footer-font-size);
                    color: var(--bluesky-footer-text-color);
                    padding: var(--bluesky-spacing-xs);
                  }

                  .comment-footer div {
                    display: flex;
                    align-items: center;
                    gap: var(--bluesky-spacing-xs);
                  }

                  .comment-content {
                    padding: var(--bluesky-spacing-xs) 0;
                    margin: 0px;
                  }

                  .comment-link {
                    display: flex;
                    flex-direction: column;
                    color: inherit;
                    text-decoration: none;
                    padding: 0 var(--bluesky-spacing-sm);
                  }

                  .profile-link {
                    color: var(--bluesky-text-color);
                    font-weight: 600;
                    text-decoration: none;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                  }

                  .start-message {
                    color: var(--bluesky-text-color);
                  }

                  .start-message-here-link {
                    font-weight: 500;
                    color: rgb(var(--theme-link)/1);
                  }

                  .start-message-reply-line{
                    border-radius: 0.5rem;
                    padding: 0.25rem;
                    background-color: rgb(var(--theme-quote) / 0.1);
                  }

                  .timestamp-link,
                  .handle-link {
                    color: var(--bluesky-handle-color);
                    text-decoration: none;
                  }

                  .timestamp-link {
                    margin-left: auto; /* pushes timestamp to the right */
                    white-space: nowrap; /* prevents timestamp from wrapping */
                  }

                  .profile-link:hover {
                    text-decoration: underline;
                  }

                  .handle {
                    color: var(--bluesky-handle-color);
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                  }

                  .comment-footer svg {
                    width: var(--bluesky-icon-size);
                    height: var(--bluesky-icon-size);
                    color: var(--bluesky-footer-text-color);
                  }
                  </style>
                  <div class="comments"></div>
                  `;
                  this.#observer = new IntersectionObserver(
                    (entries) => {
                      entries.forEach((entry) => {
                        if (entry.isIntersecting && !this.#loaded) {
                          this.#loadComments();
                          this.#loaded = true;
                          this.#observer.disconnect();
                        }
                      });
                    },
                    { threshold: 0.1 },
                  );
                }

                connectedCallback() {
                  this.#observer.observe(this);
                }

                disconnectedCallback() {
                  this.#observer.disconnect();
                }

                async #loadComments() {
                  const blueskyUrl = this.getAttribute("url");
                  if (blueskyUrl) {
                      try {
                          const atUri = await this.#resolvePostUrl(blueskyUrl);
                          if (!atUri) {
                              throw new Error("Failed to resolve AT URI");
                          }

                          // Convert atUri to a URL
                          const urlParts = atUri.split("/");
                          if (urlParts.length < 5 || !atUri.startsWith("at://")) {
                              throw new Error("Invalid AT URI format");
                          }

                          const did = urlParts[2];
                          const postId = urlParts[4];
                          const convertedUrl = `https://bsky.app/profile/${did}/post/${postId}`;
                          console.log("Converted URL:", convertedUrl);

                          const replies = await this.#fetchReplies(atUri);
                          this.#displayReplies(replies, convertedUrl); // Pass the converted URL
                      } catch (e) {
                        console.error("Error loading comments:", e);
                        this.shadowRoot.querySelector(".comments").innerHTML =
                          `<p>Error loading comments.</p>`;
                        this.#removeTabIfError();
                      }
                    } else {
                      this.shadowRoot.querySelector(".comments").innerHTML =
                        `<p>No post found on Bluesky.</p>`;
                      this.#removeTabIfError();
                    }
                  }

                  #removeTabIfError() {
                    const content = this.shadowRoot.querySelector(".comments").innerHTML;
                    if (
                      content.includes("Error loading comments.") ||
                      content.includes("No post found on Bluesky.")
                    ) {
                      const tabButton = document.querySelector('button[data-tab="bluesky"]');
                      const tabPane = document.querySelector("#bluesky-tab");

                      if (tabButton) tabButton.remove();
                      if (tabPane) tabPane.remove();
                      const tabs = document.querySelectorAll(".tab");
                      const tabPanes = document.querySelectorAll(".tab-pane");
                      const commentsContainer = document.querySelector("#webtrotion-post-comments");

                      // If there are no tabs, remove the container
                      if (tabs.length === 0 && commentsContainer) {
                        commentsContainer.remove();
                      } else {
                        // Activate the first tab by default
                        if (tabs.length > 0) {
                          tabs[0].click();
                        }
                      }
                    }
                  }

                async #resolvePostUrl(postUrl) {
                  let atUri;

                  if (postUrl.startsWith("at:")) {
                      return postUrl;
                  }

                  if (postUrl.startsWith("https://bsky.app/")) {
                      const urlParts = new URL(postUrl).pathname.split("/");
                      let did = urlParts[2];
                      const postId = urlParts[4];

                      if (!did || !postId) {
                          return undefined;
                      }

                      if (!did.startsWith("did:")) {
                          const cachedDid = this.#getCache(`handle:${did}`);
                          if (cachedDid) {
                              did = cachedDid;
                          } else {
                              try {
                                  const handleResolutionUrl = `https://public.api.bsky.app/xrpc/com.atproto.identity.resolveHandle?handle=${encodeURIComponent(did)}`;
                                  const handleResponse = await fetch(handleResolutionUrl);

                                  if (!handleResponse.ok) {
                                      throw new Error("Failed to resolve handle");
                                  }

                                  const handleData = await handleResponse.json();
                                  if (!handleData.did) {
                                      return undefined;
                                  }

                                  this.#setCache(`handle:${did}`, handleData.did, 86400);
                                  did = handleData.did;
                              } catch (e) {
                                  console.error(`[error] Failed to resolve handle: ${e.message || e}`);
                                  return undefined;
                              }
                          }
                      }

                      atUri = `at://${did}/app.bsky.feed.post/${postId}`;
                      return atUri;
                  } else if (
                      BLUESKY_COMM &&
                      BLUESKY_COMM["auto-search-for-match"] &&
                      BLUESKY_COMM["auto-search-for-match"]["turn-on-auto-search"] &&
                      BLUESKY_COMM["auto-search-for-match"]["author"] // Ensure author is not empty
                  ) {
                      const author = BLUESKY_COMM["auto-search-for-match"]["author"];
                      const emojiQuery = BLUESKY_COMM["auto-search-for-match"]["echo-feed-emoji"] || "*";

                      try {
                          const apiUrl = `https://public.api.bsky.app/xrpc/app.bsky.feed.searchPosts?q=${encodeURIComponent(
                              emojiQuery
                          )}&url=${encodeURIComponent(postUrl)}&author=${encodeURIComponent(
                              author
                          )}&sort=latest`;

                          console.log("URL is: " + apiUrl);

                          const response = await fetch(apiUrl);

                          if (!response.ok) {
                              throw new Error(`Failed to fetch posts: ${response.statusText}`);
                          }

                          // Parse the response JSON
                          const data = await response.json();
                          console.log("Parsed Response Data:", data);

                          if (data?.posts?.length > 0) {
                              // Filter for parent posts only
                              const parentPost = data.posts.find(
                                  (post) => !post.record.reply // Check if 'reply' field is absent
                              );

                              if (parentPost) {
                                  const uri = parentPost.uri;
                                  return uri;
                              } else {
                                  console.warn("No parent posts found.");
                                  return undefined;
                              }
                          } else {
                              throw new Error("No posts found for the given query");
                          }
                      } catch (e) {
                          console.error(`[error] Failed to fetch post using auto-search: ${e.message || e}`);
                          return undefined;
                      }
                  } else {
                      // If not a bsky.app URL and auto-search is disabled or author is empty, return undefined
                      return undefined;
                  }
              }

                #setCache(key, value, ttl = 86400) {
                  const expiry = Date.now() + ttl * 1000;
                  const cacheData = { value, expiry };
                  localStorage.setItem(key, JSON.stringify(cacheData));
                }

                #getCache(key) {
                  const cachedItem = localStorage.getItem(key);
                  if (!cachedItem) return null;

                  const { value, expiry } = JSON.parse(cachedItem);
                  if (Date.now() > expiry) {
                    localStorage.removeItem(key);
                    return null;
                  }
                  return value;
                }

                async #fetchReplies(atUri) {
                  const apiUrl = `https://public.api.bsky.app/xrpc/app.bsky.feed.getPostThread?uri=${encodeURIComponent(
                    atUri,
                  )}`;
                  const response = await fetch(apiUrl);
                  if (!response.ok) {
                    throw new Error("Failed to fetch replies");
                  }
                  const data = await response.json();
                  return data.thread;
                }

                #displayReplies(thread, blueskyUrl, container = null) {
                  const commentsContainer =
                    container || this.shadowRoot.querySelector(".comments");
                  const startMessageDiv = document.createElement("div");
                  startMessageDiv.classList.add("start-message");
                    if (thread?.post) {
                      this.#displayComments(thread, startMessageDiv, false, false);
                    }
                    startMessageDiv.innerHTML += `
                      <div class="start-message-reply-line"> Reply on Bluesky
                      <a href="${blueskyUrl}" target="_blank" rel="noopener noreferrer" class="start-message-here-link">
                        here
                      </a> to join the conversation. </div><hr>
                    `;
                  commentsContainer.appendChild(startMessageDiv);
                  if (thread && thread.replies && thread.replies.length > 0) {
                    const sortedReplies = thread.replies.sort((a, b) => {
                      return (
                        new Date(a.post.record.createdAt).getTime() -
                        new Date(b.post.record.createdAt).getTime()
                      );
                    });
                    sortedReplies.forEach((reply) => {
                      this.#displayComments(reply, commentsContainer, false);
                    });
                  }
                }

                #sanitizeText(text) {
                  const div = document.createElement("div");
                  div.textContent = text;
                  return div.innerHTML;
                }

                #displayComments(thread, container, isReply = false, renderReplies = true) {
                  if (thread?.post?.author && thread.post.record) {
                    if (thread.post.record.text.trim() === "ðŸ“Œ" || thread.post.record.text.trim() === "ðŸ”–") {
                      return;
                    }

                    const commentDiv = document.createElement("div");
                    commentDiv.classList.add("comment");
                    if (isReply) {
                      commentDiv.classList.add("reply");
                    }

                    const authorHandle = thread.post.author.handle;
                    const authorProfileUrl = `https://bsky.app/profile/${thread.post.author.did}`;
                    const postUrl = `https://bsky.app/profile/${
                      thread.post.author.did
                    }/post/${thread.post.uri.split("/").pop()}`;
                    const createdAt = new Date(thread.post.record.createdAt);
                    const createdAtFull = createdAt.toLocaleString();
                    const createdAtAbbreviated = this.#getAbbreviatedTime(createdAt);
                    const avatarUrl = thread.post?.author?.avatar?.replace(
                      "/img/avatar/",
                      "/img/avatar_thumbnail/",
                    );
                    const displayName = thread.post.author.displayName || authorHandle;
                    const likeCount = thread.post.likeCount || 0;
                    const repostCount = thread.post.repostCount || 0;
                    const replyCount = thread.post.replyCount || 0;

                    let avatarElement;
                    if (avatarUrl) {
                      avatarElement = `<img src="${avatarUrl}" alt="${authorHandle}'s avatar" class="avatar" part="avatar"/>`;
                    } else {
                      avatarElement = `<div class="default-avatar" part="avatar"></div>`;
                    }
                    commentDiv.innerHTML = `
                      <div class="comment-header" part="comment-header">
                        ${avatarElement}
                        <div>
                          <a href="${authorProfileUrl}" target="_blank" class="profile-link">${this.#sanitizeText(displayName)}</a>
                          <span class="handle"><a href="${authorProfileUrl}" target="_blank" class="handle-link">@${this.#sanitizeText(authorHandle)}</a></span>
                          <a href="${postUrl}" target="_blank" rel="ugc" title="${createdAtFull}" class="timestamp-link">${createdAtAbbreviated}</a>
                        </div>
                      </div>
                      <div class="comment-body" part="comment-body">
                        <a href="${postUrl}" target="_blank" rel="nofollow noopener" class="comment-link">
                          <p class="comment-content" part="comment-content">
                            ${this.#sanitizeText(thread.post.record.text)}</p>
                          <div class="comment-footer" part="comment-footer">
                            <div>
                              <svg viewBox="0 0 24 24">
                                <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M2.002 6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3H12.28l-4.762 2.858A1 1 0 0 1 6.002 21v-2h-1a3 3 0 0 1-3-3V6Zm3-1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h2a1 1 0 0 1 1 1v1.234l3.486-2.092a1 1 0 0 1 .514-.142h7a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-14Z"></path>
                              </svg>
                              <span>${replyCount}</span>
                            </div>
                            <div>
                              <svg viewBox="0 0 24 24">
                                <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M17.957 2.293a1 1 0 1 0-1.414 1.414L17.836 5H6a3 3 0 0 0-3 3v3a1 1 0 1 0 2 0V8a1 1 0 0 1 1-1h11.836l-1.293 1.293a1 1 0 0 0 1.414 1.414l2.47-2.47a1.75 1.75 0 0 0 0-2.474l-2.47-2.47ZM20 12a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3H6.164l1.293 1.293a1 1 0 1 1-1.414 1.414l-2.47-2.47a1.75 1.75 0 0 1 0-2.474l2.47-2.47a1 1 0 0 1 1.414 1.414L6.164 17H18a1 1 0 0 0 1-1v-3a1 1 0 0 1 1-1Z"></path>
                              </svg>
                              <span>${repostCount}</span>
                            </div>
                            <div>
                              <svg viewBox="0 0 24 24">
                                <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M16.734 5.091c-1.238-.276-2.708.047-4.022 1.38a1 1 0 0 1-1.424 0C9.974 5.137 8.504 4.814 7.266 5.09c-1.263.282-2.379 1.206-2.92 2.556C3.33 10.18 4.252 14.84 12 19.348c7.747-4.508 8.67-9.168 7.654-11.7-.541-1.351-1.657-2.275-2.92-2.557Zm4.777 1.812c1.604 4-.494 9.69-9.022 14.47a1 1 0 0 1-.978 0C2.983 16.592.885 10.902 2.49 6.902c.779-1.942 2.414-3.334 4.342-3.764 1.697-.378 3.552.003 5.169 1.286 1.617-1.283 3.472-1.664 5.17-1.286 1.927.43 3.562 1.822 4.34 3.764Z"></path>
                              </svg>
                              <span>${likeCount}</span>
                            </div>
                          </div>
                        </a>
                      </div>
                    `;

                    container.appendChild(commentDiv);

                    if (renderReplies && thread.replies && thread.replies.length > 0) {
                      const sortedReplies = thread.replies.sort((a, b) => {
                        return (
                          new Date(a.post.record.createdAt).getTime() -
                          new Date(b.post.record.createdAt).getTime()
                        );
                      });
                      sortedReplies.forEach((reply) => {
                        this.#displayComments(reply, commentDiv, true);
                      });
                    }
                  }
                }

                #getAbbreviatedTime(date) {
                  const now = new Date().getTime();
                  const diffMs = now - date;
                  const diffSeconds = Math.floor(diffMs / 1000);
                  const diffMinutes = Math.floor(diffSeconds / 60);
                  const diffHours = Math.floor(diffMinutes / 60);
                  const diffDays = Math.floor(diffHours / 24);

                  if (diffDays > 0) {
                    return `${diffDays}d`;
                  } else if (diffHours > 0) {
                    return `${diffHours}h`;
                  } else if (diffMinutes > 0) {
                    return `${diffMinutes}m`;
                  } else {
                    return `${diffSeconds}s`;
                  }
                }
              }
              customElements.define("bluesky-comments", BlueskyComments);
            </script>
          </div>
        )}
        {filled_in_giscus && (
          <div class="tab-pane w-full" id="giscus-tab" hidden>
            <section
              class="giscus mx-auto mt-6 w-full"
              id="--layout-div-giscus-post-comments"
            />
            <script
              src="https://giscus.app/client.js"
              data-repo={GISCUS["data-repo"]}
              data-repo-id={GISCUS["data-repo-id"]}
              data-category={GISCUS["data-category"]}
              data-category-id={GISCUS["data-category-id"]}
              data-mapping={GISCUS["data-mapping"] || "url"}
              data-strict="0"
              data-reactions-enabled={GISCUS["data-reactions-enabled"] ? "1" : "0"}
              data-emit-metadata="0"
              data-input-position={GISCUS["data-input-position"] || "bottom"}
              data-theme="preferred_color_scheme"
              data-lang="en"
              data-loading="lazy"
              crossorigin="anonymous"
              async
            />
          </div>
        )}
      </div>
    </div>
  </div>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const tabs = document.querySelectorAll(".tab");
      const tabPanes = document.querySelectorAll(".tab-pane");

      tabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          document.startViewTransition(() => {
            const targetTab = tab.dataset.tab;

            tabPanes.forEach((pane) => {
              pane.hidden = pane.id !== `${targetTab}-tab`;
            });

            tabs.forEach((t) => t.classList.remove("active"));
            tab.classList.add("active");
          });
        });
      });

      // Activate the first tab by default
      if (tabs.length > 0) {
        tabs[0].click();
      }
    });
  </script>

  <style>

    .tab.active {
      border-bottom: 2px solid rgb(var(--theme-accent)) !important;
    }
    .tab-pane {
      display: none;
    }
    .tab-pane:not([hidden]) {
      display: block;
    }
  </style>
)}

