---
import { SHORTCODES } from "@/constants";
import * as interfaces from "@/lib/interfaces.ts";
import RichText from "@/components/notion-blocks/RichText.astro";
import { joinPlainText } from "@/utils/richtext-utils";

export interface Props {
	block: interfaces.Block;
	setId?: boolean;
}

const { block, setId = true } = Astro.props;

// Check if the first cell starts with SHORTCODES.table
const plainTextFirstCell = joinPlainText(block.Table?.Rows[0]?.Cells[0]?.RichTexts || []);
const isDataTable =
	plainTextFirstCell && block.Table?.HasColumnHeader
		? plainTextFirstCell.startsWith(SHORTCODES.table)
		: false;
const tableClass = isDataTable ? "datatable" : "";

// Remove SHORTCODES.table from the first cell if it exists
if (isDataTable && block.Table?.Rows[0]?.Cells[0]?.RichTexts[0]?.Text?.Content) {
	block.Table.Rows[0].Cells[0].RichTexts[0].Text.Content =
		block.Table.Rows[0].Cells[0].RichTexts[0].Text.Content.replace(SHORTCODES.table, "").trim();
}

const coltype_identifiers = {
	boolean: "‚òëÔ∏è",
	number: "üî¢",
	datetime: "üìÖ",
	//"tag": "üè∑Ô∏è",
};
function getColumnType(cellContent: string) {
	for (const [type, emoji] of Object.entries(coltype_identifiers)) {
		if (cellContent.startsWith(emoji)) {
			return type;
		}
	}
	return "html";
}
---

<div class="ntable" id={setId ? block.Id : undefined}>
	<table class={tableClass}>
		<thead>
			{
				block.Table?.HasColumnHeader && (
					<tr>
						{block.Table.Rows[0]?.Cells.map((cell: interfaces.TableCell, i: number) => {
							if (isDataTable) {
								const cellContent = joinPlainText(cell.RichTexts);
								const columnType = getColumnType(cellContent);
								return (
									<th scope="col" data-type={columnType}>
										{cell.RichTexts.map((richText: interfaces.RichText) => (
											<RichText richText={richText} blockID={block.Id} block={block} />
										))}
									</th>
								);
							} else {
								return (
									<th scope="col">
										{cell.RichTexts.map((richText: interfaces.RichText) => (
											<RichText richText={richText} blockID={block.Id} block={block} />
										))}
									</th>
								);
							}
						})}
					</tr>
				)
			}
		</thead>
		<tbody>
			{
				block.Table?.Rows.map((tableRow: interfaces.TableRow, j: number) => {
					// Skip the first row if it's a header row
					if (block.Table?.HasColumnHeader && j === 0) return null;

					return (
						<tr>
							{tableRow.Cells.map((cell: interfaces.TableCell, i: number) => {
								if (block.Table?.HasRowHeader && i === 0) {
									return (
										<th scope="row" class="table-row-header">
											{cell.RichTexts.map((richText: interfaces.RichText) => (
												<RichText richText={richText} blockID={block.Id} block={block} />
											))}
										</th>
									);
								}
								return (
									<td>
										{cell.RichTexts.map((richText: interfaces.RichText) => (
											<RichText richText={richText} blockID={block.Id} block={block} />
										))}
									</td>
								);
							})}
						</tr>
					);
				})
			}
		</tbody>
	</table>
</div>
